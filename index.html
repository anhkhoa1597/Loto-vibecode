<!doctype html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>L√¥ T√¥</title>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <header class="topbar">
      <div class="container topbar__inner">
        <div class="topbar__row1">
          <h1 class="title">L√¥ T√¥</h1>
          <div class="pill">
            M√£ t·ªù: <code id="seedText">--</code>
            <button
              id="btnCopyLink"
              class="iconBtn"
              type="button"
              title="Sao ch√©p li√™n k·∫øt"
              aria-label="Sao ch√©p li√™n k·∫øt"
            >
              üîó
            </button>
          </div>
        </div>

        <div class="row">
          <div class="pill">
            Ch·∫ø ƒë·ªô:
            <button id="modePlayer" class="seg is-on" type="button">
              Ng∆∞·ªùi ch∆°i
            </button>
            <button id="modeCaller" class="seg" type="button">Ng∆∞·ªùi g·ªçi</button>
          </div>

          <div class="pill">
            T·ªù:
            <button id="oneTicket" class="seg is-on" type="button">ƒê∆°n</button>
            <button id="twoTicket" class="seg" type="button">ƒê√¥i</button>
          </div>
        </div>

        <p
          id="ticketLockHint"
          class="subtitle"
          style="margin: 0; display: none"
        >
          ƒêang c√≥ ƒë√°nh d·∫•u ‚Üí kh√¥ng ƒë·ªïi ƒë∆∞·ª£c 1/2 t·ªù.
        </p>
      </div>
    </header>

    <main class="container stack">
      <section class="card">
        <div class="card__head">
          <div class="row" style="justify-content: flex-start; gap: 10px">
            <div class="pill" aria-label="tools">
              <button
                id="btnNewCard"
                class="seg"
                type="button"
                title="T·ªù m·ªõi"
                aria-label="T·ªù m·ªõi"
              >
                T·∫°o T·ªù M·ªõi
              </button>
              <button
                id="btnResetMarks"
                class="seg"
                type="button"
                title="X√≥a ƒë√°nh d·∫•u"
                aria-label="X√≥a ƒë√°nh d·∫•u"
              >
                T·∫°o l·∫°i
              </button>
            </div>
            <div id="callerAutoWrap" class="pill" style="display: none">
              ƒê√°nh d·∫•u:
              <button id="autoMarkOff" class="seg is-on" type="button">
                Th·ªß c√¥ng
              </button>
              <button id="autoMarkOn" class="seg" type="button">T·ª± ƒë·ªông</button>
            </div>
          </div>
        </div>

        <div class="card__body">
          <!-- Ticket area is the main screen -->
          <div class="ticketsWrap">
            <div class="tickets" id="tickets">
              <div class="ticket ticket--snap">
                <div class="ticket__grid" id="grid1"></div>
              </div>

              <div
                class="ticket ticket--snap"
                id="ticket2Wrap"
                style="display: none"
              >
                <div class="ticket__grid" id="grid2"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <div class="footer">Ch√∫c c·∫£ nh√≥m ch∆°i vui!</div>
    </main>

    <!-- Caller dock (fixed, same screen as ticket) -->
    <div id="callerDock" class="callerDock" style="display: none">
      <div class="callerDock__inner">
        <div class="callerLeft">
          <div class="callerNum" id="currentNumber">--</div>
          <div class="callerMeta">
            <span class="callerCount">ƒê√£ ra: <b id="calledCount">0</b>/90</span>
          </div>
        </div>

        <div class="callerRight">
          <button
            id="btnDraw"
            class="dockBtn dockBtn--primary"
            type="button"
            aria-label="B·ªëc s·ªë"
          >
            üé≤ B·ªëc
          </button>
          <button
            id="btnHistory"
            class="dockIcon"
            type="button"
            title="L·ªãch s·ª≠"
            aria-label="L·ªãch s·ª≠"
          >
            üßæ
          </button>
          <button
            id="btnResetCall"
            class="dockIcon"
            type="button"
            title="Reset l∆∞·ª£t b·ªëc"
            aria-label="Reset l∆∞·ª£t b·ªëc"
          >
            üîÑ
          </button>
        </div>
      </div>
    </div>

    <!-- History Modal -->
    <div id="backdrop" class="backdrop" role="dialog" aria-modal="true">
      <div class="modal">
        <div class="modal__head">
          <div>
            <div class="title" style="font-size: 15px; margin: 0">
              L·ªãch s·ª≠ s·ªë ƒë√£ ra
            </div>
            <div class="subtitle" style="margin-top: 4px">
              Theo th·ª© t·ª± t·ª´ ƒë·∫ßu ƒë·∫øn hi·ªán t·∫°i.
            </div>
          </div>
          <button id="btnClose" class="btn btn--ghost btn--small" type="button">
            ‚úñ
          </button>
        </div>
        <div class="modal__body">
          <div id="historyChips" class="chips"></div>
          <div
            id="historyEmpty"
            class="subtitle"
            style="display: none; margin-top: 6px"
          >
            Ch∆∞a c√≥ s·ªë n√†o.
          </div>
        </div>
      </div>
    </div>

    <script>
      /* =======================
   Helpers: seed + rng
======================= */
      function bytesToHex(bytes) {
        return [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
      }
      function makeSeed128() {
        const buf = new Uint8Array(16);
        crypto.getRandomValues(buf);
        return bytesToHex(buf);
      }
      function seedToUint32(seedHex) {
        let x = 0;
        for (let i = 0; i < seedHex.length; i += 8) {
          const chunk = parseInt(seedHex.slice(i, i + 8), 16) >>> 0;
          x = (x ^ chunk) >>> 0;
        }
        return x >>> 0;
      }
      function mulberry32(a) {
        return function () {
          let t = (a += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      function shuffleWithRand(arr, rand) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(rand() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      function cryptoRandInt(min, max) {
        const range = max - min + 1;
        const maxUnbiased = Math.floor(0x100000000 / range) * range;
        let x;
        do {
          x = crypto.getRandomValues(new Uint32Array(1))[0];
        } while (x >= maxUnbiased);
        return min + (x % range);
      }

      /* =======================
   Ticket rules: 9x9
======================= */
      const ROWS = 9,
        COLS = 9;

      const RANGES = [
        [1, 9],
        [10, 19],
        [20, 29],
        [30, 39],
        [40, 49],
        [50, 59],
        [60, 69],
        [70, 79],
        [80, 90],
      ];

      function makeTargetsForTicket1(rand) {
        // base all 5 => sum 45
        const t = Array(COLS).fill(5);

        // Make some (6,4) pairs; constraints for complement validity:
        // col0 cannot be 6 (because total 9) => only 4 or 5
        // col8 cannot be 4 (because total 11) => only 5 or 6
        const maxPairs = 4;
        const nPairs = Math.floor(rand() * (maxPairs + 1));

        for (let k = 0; k < nPairs; k++) {
          const incCandidates = [];
          for (let c = 0; c < COLS; c++) {
            if (t[c] === 5 && c !== 0) incCandidates.push(c);
          }
          const decCandidates = [];
          for (let c = 0; c < COLS; c++) {
            if (t[c] === 5 && c !== 8) decCandidates.push(c);
          }
          if (!incCandidates.length || !decCandidates.length) break;

          const inc = incCandidates[Math.floor(rand() * incCandidates.length)];
          const dec = decCandidates[Math.floor(rand() * decCandidates.length)];
          if (inc === dec) continue;

          t[inc] = 6;
          t[dec] = 4;
        }

        // final sanity
        const sum = t.reduce((a, b) => a + b, 0);
        if (sum !== 45) return Array(COLS).fill(5);
        if (!(t[0] === 4 || t[0] === 5)) return Array(COLS).fill(5);
        if (!(t[8] === 5 || t[8] === 6)) return Array(COLS).fill(5);
        for (let c = 0; c < COLS; c++)
          if (t[c] < 4 || t[c] > 6) return Array(COLS).fill(5);
        return t;
      }

      function tryPlacement(target, seed32, attempt) {
        const r2 = mulberry32((seed32 ^ (attempt * 0x9e3779b9)) >>> 0);
        const remaining = target.slice();
        const place = Array.from({ length: ROWS }, () =>
          Array(COLS).fill(false),
        );

        for (let r = 0; r < ROWS; r++) {
          const cols = [];
          for (let c = 0; c < COLS; c++) if (remaining[c] > 0) cols.push(c);
          if (cols.length < 5) return null;

          cols.sort((a, b) => {
            const da = remaining[a],
              db = remaining[b];
            if (db !== da) return db - da;
            return r2() - r2();
          });

          const chosen = cols.slice(0, 5);
          for (const c of chosen) {
            place[r][c] = true;
            remaining[c]--;
            if (remaining[c] < 0) return null;
          }
        }

        for (let c = 0; c < COLS; c++) if (remaining[c] !== 0) return null;
        return place;
      }

      function pickUniqueFromPool(pool, count, rand) {
        const copy = pool.slice();
        shuffleWithRand(copy, rand);
        return copy.slice(0, count).sort((a, b) => a - b);
      }

      function buildOneTicket(seedHex, target, numberPoolsByCol) {
        const seed32 = seedToUint32(seedHex);
        const rand = mulberry32(seed32);

        let place = null;
        for (let attempt = 0; attempt < 900; attempt++) {
          place = tryPlacement(target, seed32, attempt);
          if (place) break;
        }
        if (!place) place = tryPlacement(target, seed32, 999999);

        const colNums = [];
        for (let c = 0; c < COLS; c++) {
          colNums[c] = pickUniqueFromPool(numberPoolsByCol[c], target[c], rand);
        }

        const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        for (let c = 0; c < COLS; c++) {
          const rows = [];
          for (let r = 0; r < ROWS; r++) if (place[r][c]) rows.push(r);
          rows.sort((a, b) => a - b);
          for (let i = 0; i < rows.length; i++) {
            grid[rows[i]][c] = colNums[c][i];
          }
        }
        return { grid, usedByCol: colNums };
      }

      function buildTickets(seedHex) {
        const seed32 = seedToUint32(seedHex);
        const rand = mulberry32(seed32);

        const fullPools = RANGES.map(([lo, hi]) => {
          const pool = [];
          for (let x = lo; x <= hi; x++) pool.push(x);
          return pool;
        });

        const target1 = makeTargetsForTicket1(rand);
        const t1 = buildOneTicket(seedHex, target1, fullPools);

        const remPools = fullPools.map((pool, c) => {
          const used = new Set(t1.usedByCol[c]);
          return pool.filter((n) => !used.has(n));
        });

        const target2 = remPools.map((p) => p.length);
        const seed2 = (seedHex + "9").slice(0, seedHex.length);
        const t2 = buildOneTicket(seed2, target2, remPools);

        return { t1: t1.grid, t2: t2.grid };
      }

      /* =======================
   State
======================= */
      const LS_KEY = "loto_onepage_v2";
      let state = {
        seed: null,
        mode: "player", // "player" | "caller"
        tickets: 1, // 1 | 2
        autoMark: false, // caller option
        markedNums: [],
        markedCells: [], // includes ticket index
        called: [],
        current: null,
      };

      function loadState() {
        const raw = localStorage.getItem(LS_KEY);
        if (raw) {
          try {
            state = { ...state, ...JSON.parse(raw) };
          } catch {}
        }

        const url = new URL(location.href);
        const seedParam = url.searchParams.get("seed");
        if (seedParam && /^[0-9a-fA-F]{16,64}$/.test(seedParam)) {
          const sp = seedParam.toLowerCase();
          if (state.seed !== sp) {
            state.seed = sp;
            state.markedNums = [];
            state.markedCells = [];
            state.called = [];
            state.current = null;
          }
        }

        if (!state.seed) state.seed = makeSeed128();
        if (![1, 2].includes(state.tickets)) state.tickets = 1;
        if (!["player", "caller"].includes(state.mode)) state.mode = "player";
        if (typeof state.autoMark !== "boolean") state.autoMark = false;
        if (!Array.isArray(state.markedNums)) state.markedNums = [];
        if (!Array.isArray(state.markedCells)) state.markedCells = [];
        if (!Array.isArray(state.called)) state.called = [];
      }
      function saveState() {
        localStorage.setItem(LS_KEY, JSON.stringify(state));
      }

      /* =======================
   UI refs
======================= */
      const seedText = document.getElementById("seedText");

      const modePlayer = document.getElementById("modePlayer");
      const modeCaller = document.getElementById("modeCaller");

      const oneTicket = document.getElementById("oneTicket");
      const twoTicket = document.getElementById("twoTicket");
      const ticketLockHint = document.getElementById("ticketLockHint");

      const btnNewCard = document.getElementById("btnNewCard");
      const btnResetMarks = document.getElementById("btnResetMarks");
      const btnCopyLink = document.getElementById("btnCopyLink");

      const callerDock = document.getElementById("callerDock");
      const callerAutoWrap = document.getElementById("callerAutoWrap");
      const autoMarkOff = document.getElementById("autoMarkOff");
      const autoMarkOn = document.getElementById("autoMarkOn");

      const currentNumber = document.getElementById("currentNumber");
      const calledCount = document.getElementById("calledCount");
      const btnDraw = document.getElementById("btnDraw");
      const btnHistory = document.getElementById("btnHistory");
      const btnResetCall = document.getElementById("btnResetCall");

      const grid1 = document.getElementById("grid1");
      const grid2 = document.getElementById("grid2");
      const ticket2Wrap = document.getElementById("ticket2Wrap");

      const backdrop = document.getElementById("backdrop");
      const btnClose = document.getElementById("btnClose");
      const historyChips = document.getElementById("historyChips");
      const historyEmpty = document.getElementById("historyEmpty");

      let markedNumSet = new Set();
      let markedCellSet = new Set();
      let calledSet = new Set();
      let cachedTickets = null;

      /* =======================
   Render
======================= */
      function setSegActive(elOn, elOff) {
        elOn.classList.add("is-on");
        elOff.classList.remove("is-on");
      }
      function setSegBool(onEl, offEl, value) {
        if (value) {
          onEl.classList.add("is-on");
          offEl.classList.remove("is-on");
        } else {
          offEl.classList.add("is-on");
          onEl.classList.remove("is-on");
        }
      }

      function updateHeader() {
        seedText.textContent = state.seed;

        const url = new URL(location.href);
        url.searchParams.set("seed", state.seed);
        history.replaceState({}, "", url);

        const marks = markedNumSet.size + markedCellSet.size;
        const locked = marks > 0;

        ticketLockHint.style.display = locked ? "" : "none";
        oneTicket.disabled = locked;
        twoTicket.disabled = locked;
        oneTicket.classList.toggle("is-disabled", locked);
        twoTicket.classList.toggle("is-disabled", locked);

        if (state.mode === "caller") {
          calledCount.textContent = String(state.called.length);
          currentNumber.textContent =
            state.current == null ? "--" : String(state.current);
        }
      }

      function renderMode() {
        if (state.mode === "caller") {
          setSegActive(modeCaller, modePlayer);
          callerDock.style.display = "";
          callerAutoWrap.style.display = "";
          setSegBool(autoMarkOn, autoMarkOff, state.autoMark);
        } else {
          setSegActive(modePlayer, modeCaller);
          callerDock.style.display = "none";
          callerAutoWrap.style.display = "none";
        }
      }

      function renderTickets() {
        if (!cachedTickets) cachedTickets = buildTickets(state.seed);

        if (state.tickets === 2) {
          setSegActive(twoTicket, oneTicket);
          ticket2Wrap.style.display = "";
        } else {
          setSegActive(oneTicket, twoTicket);
          ticket2Wrap.style.display = "none";
        }

        renderGrid(grid1, cachedTickets.t1, 1);
        if (state.tickets === 2) renderGrid(grid2, cachedTickets.t2, 2);

        updateHeader();
      }

      function renderGrid(el, grid, ticketIndex) {
        el.innerHTML = "";
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const val = grid[r][c];
            const cellKey = `${ticketIndex}-${r}-${c}`;

            const b = document.createElement("button");
            b.type = "button";

            if (val == null) {
              b.className = "cell cell--empty";
              b.textContent = " ";
              if (markedCellSet.has(cellKey)) b.classList.add("is-marked");

              b.addEventListener("click", () => {
                if (markedCellSet.has(cellKey)) {
                  markedCellSet.delete(cellKey);
                  b.classList.remove("is-marked");
                } else {
                  markedCellSet.add(cellKey);
                  b.classList.add("is-marked");
                }
                state.markedCells = [...markedCellSet];
                saveState();
                updateHeader();
              });
            } else {
              b.className = "cell";
              b.textContent = String(val);
              if (markedNumSet.has(val)) b.classList.add("is-marked");

              b.addEventListener("click", () => {
                if (markedNumSet.has(val)) {
                  markedNumSet.delete(val);
                  b.classList.remove("is-marked");
                } else {
                  markedNumSet.add(val);
                  b.classList.add("is-marked");
                }
                state.markedNums = [...markedNumSet];
                saveState();
                updateHeader();
              });
            }

            el.appendChild(b);
          }
        }
      }

      /* =======================
   Actions
======================= */
      function newCard() {
        if (
          !confirm("T·∫°o t·ªù m·ªõi? S·∫Ω ƒë·ªïi m√£ t·ªù v√† x√≥a ƒë√°nh d·∫•u + l·ªãch s·ª≠ b·ªëc s·ªë.")
        )
          return;

        state.seed = makeSeed128();
        state.markedNums = [];
        state.markedCells = [];
        state.called = [];
        state.current = null;

        markedNumSet = new Set();
        markedCellSet = new Set();
        calledSet = new Set();

        cachedTickets = null;
        saveState();
        renderAll();
      }

      function resetMarks() {
        if (!confirm("X√≥a to√†n b·ªô ƒë√°nh d·∫•u tr√™n t·ªù hi·ªán t·∫°i?")) return;

        state.markedNums = [];
        state.markedCells = [];
        markedNumSet = new Set();
        markedCellSet = new Set();
        saveState();
        renderTickets(); // re-render to clear
      }

      async function copyLink() {
        const url = new URL(location.href);
        url.searchParams.set("seed", state.seed);
        try {
          await navigator.clipboard.writeText(url.toString());
          btnCopyLink.textContent = "‚úÖ";
          setTimeout(() => (btnCopyLink.textContent = "üîó"), 900);
        } catch {
          prompt("Sao ch√©p li√™n k·∫øt n√†y:", url.toString());
        }
      }

      function setMode(mode) {
        state.mode = mode;
        saveState();
        renderAll();
      }

      function setTicketsMode(n) {
        const locked = markedNumSet.size + markedCellSet.size > 0;
        if (locked) return;
        state.tickets = n;
        saveState();
        renderAll();
      }

      function setAutoMark(v) {
        state.autoMark = v;
        saveState();
        renderMode();
      }

      function drawNumber() {
        if (state.called.length >= 90) {
          alert("ƒê√£ ra h·∫øt 90 s·ªë!");
          return;
        }
        const remaining = [];
        for (let i = 1; i <= 90; i++) {
          if (!calledSet.has(i)) remaining.push(i);
        }
        const n = remaining[cryptoRandInt(0, remaining.length - 1)];
        state.current = n;
        state.called.push(n);
        calledSet.add(n);

        // ‚úÖ auto mark if enabled
        if (state.autoMark) {
          markedNumSet.add(n);
          state.markedNums = [...markedNumSet];
        }

        saveState();
        renderTickets(); // updates number + called count + marks
      }

      function resetCall() {
        if (
          !confirm(
            "Reset l∆∞·ª£t b·ªëc? S·∫Ω x√≥a l·ªãch s·ª≠ s·ªë ƒë√£ ra v√† x√≥a to√†n b·ªô ƒë√°nh d·∫•u (gi·ªØ nguy√™n t·ªù).",
          )
        )
          return;

        state.called = [];
        state.current = null;
        calledSet = new Set();

        // also clear marks, keep seed
        state.markedNums = [];
        state.markedCells = [];
        markedNumSet = new Set();
        markedCellSet = new Set();

        saveState();
        renderAll();
      }

      function openHistory() {
        historyChips.innerHTML = "";
        if (state.called.length === 0) {
          historyEmpty.style.display = "";
        } else {
          historyEmpty.style.display = "none";
          state.called.forEach((n) => {
            const chip = document.createElement("span");
            chip.className = "chip";
            chip.textContent = n;
            historyChips.appendChild(chip);
          });
        }
        backdrop.classList.add("open");
      }
      function closeHistory() {
        backdrop.classList.remove("open");
      }

      /* =======================
   Render all
======================= */
      function renderAll() {
        renderMode();
        cachedTickets = cachedTickets || buildTickets(state.seed);
        renderTickets();
        updateHeader();
      }

      /* =======================
   Boot
======================= */
      loadState();

      markedNumSet = new Set(state.markedNums);
      markedCellSet = new Set(state.markedCells);
      calledSet = new Set(state.called);

      renderAll();

      /* =======================
   Events
======================= */
      btnNewCard.addEventListener("click", newCard);
      btnResetMarks.addEventListener("click", resetMarks);
      btnCopyLink.addEventListener("click", copyLink);

      modePlayer.addEventListener("click", () => setMode("player"));
      modeCaller.addEventListener("click", () => setMode("caller"));

      oneTicket.addEventListener("click", () => setTicketsMode(1));
      twoTicket.addEventListener("click", () => setTicketsMode(2));

      autoMarkOff.addEventListener("click", () => setAutoMark(false));
      autoMarkOn.addEventListener("click", () => setAutoMark(true));

      btnDraw.addEventListener("click", drawNumber);
      btnHistory.addEventListener("click", openHistory);
      btnResetCall.addEventListener("click", resetCall);

      btnClose.addEventListener("click", closeHistory);
      backdrop.addEventListener("click", (e) => {
        if (e.target === backdrop) closeHistory();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeHistory();
      });
    </script>
  </body>
</html>
